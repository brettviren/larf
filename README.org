#+TITLE: LArTPC Field Calculation Using BEM

* Overview

*Note: this package is still a work in progress!*

*Note: this documentation is still a mish mash and may not represent reality!*

This package provides calculations which can be used to determine the field response of drifting charge in a LArTPC.  It does this by providing various calculations:

 - [ ] applied electrostatic drift field in 3D
 - [ ] [[https://en.wikipedia.org/wiki/Shockley%E2%80%93Ramo_theorem][Shockley-Ramo]] weighting fields for each wire in 3D
 - [ ] electrode currents as a function of time by stepping test charges through these fields
 - [ ] average field response functions

As each of the above is done it is checked off.

The field calculations are performed in 3D using the [[https://en.wikipedia.org/wiki/Boundary_element_method][Boundary Element Method.]]  

More information on the method and results is provided under [[./docs/]].

* Installation

** Install prerequisites for generating meshes

#+BEGIN_SRC sh
  $ sudo apt-get install gmsh
  $ virtualenv --system-site-packages venv
  $ source venv/bin/activate
  $ pip install pygmsh meshio nose
#+END_SRC

** Install BEM++

See [[http://www.bempp.org/installation.html][BEM++ install instructions]].  Eg:

#+BEGIN_SRC sh
  $ wget http://www.bempp.org/files/python-bempp_wily_3.0.3_amd64.deb
  $ sudo dpkg -i python-bempp_wily_3.0.3_amd64.deb
  $ sudo apt-get -f install
#+END_SRC

If =dpkg= command will fail the subsequent =apt-get= will install missing dependencies and complete the BEM++ installation.

** Install lartpc-field itself

#+BEGIN_SRC sh
  $ git clone ...
  $ cd lartpc-field
  $ python setup.py install
  # or 
  $ python setup.py develop
  $ larf 
#+END_SRC


* Running

The calculation is run through the =larf= command line tool.  The calculation requires these steps:

1. Generate a mesh for electrode surfaces.
2. Solve the Laplace equation for given boundary conditions.
3. Evaluate solution at some set of points in the volume.
4. Plot or otherwise use the results.

The result of each step can (and should) be saved for use as input for the subsequent step.  Each step is described further in the following sections.

** Mesh

The "mesh" (or "grid" in BEM++ language) describes the boundary surface in terms of facets (triangles in this case).  The mesh is defined in terms of three quantities:

- =vertices= :: a 2D array of 3D Cartesian coordinates of points from which the facets are made.
- =elements= :: a 2D array of ordered triplets of indices into the vertices array.  The ordering is such that the normal direction produced by the right-hand-rule points into the region of zero field (ie, into the material or away from the volume where the field is to be calculated).
- =domains= :: a 1D array with each entry providing a domain index for each entry in the /elements/ array.  Domain indices are simply numbers used to associate a set of mesh elements (this is used to assign a boundary potential).

Meshes can be provided in a number of ways:

- [[http://gmsh.info/doc/texinfo/gmsh.html#MSH-ASCII-file-format][MSH ASCII format]] files with care taken to encode the domain indices.
- Numpy =.npz= format with keys named as in the above list.
- Generated internally by =larf mesh=

To generate a mesh with =larf mesh= one names a =[mesh]= section in the =larf.cfg= file.  More info on configuration is below.  Generated meshes can be saved to one of the supported file formats:

#+BEGIN_SRC sh
  $ larf mesh -o one.msh one
  $ larf mesh -o parallel.npz parallel
  $ larf mesh -o uboone.npz -o uboone.msh uboone
#+END_SRC

Meshes in MSH format can be easily viewed with =gmsh=:

#+BEGIN_SRC sh
  $ gmsh uboone.msh
#+END_SRC


** Solve

This step integrates the Laplace equation and evaluates that solution
at the boundary using potentials defined on the mesh.  Ultimately,
boundary potentials are defined in terms of the domain indices
(described above).  There are two classes of potentials to solve:
/drift/ and /weighting/.  Solving for the /drift/ potential requires
some detailed boundary potential specification and is accomplished by
mapping individual or ranges of domain indices to voltage values.
The /weighting/ potential requires only specifying which domain to
focus on, setting it to unit voltage and setting all other domains to
0V.  To simplify the specification each case has its own rule to apply
parameters to define the potential.  This is all specified through the
command line and configuration file.

#+BEGIN_SRC sh
  $ larf solve -p weghting -d 11 -o parallel-near-d10.npz parallel.msh
  $ larf solve -p drift          -o parallel-drift.npz parallel.msh
#+END_SRC

The first example uses the /weighting/ potential defined in =larf.cfg= with the domain index 11 called out as special (ie, that wire will be set to 1V).  The second example uses the /drift/ potential defined in =larf.cfg=.  In that definition the potential of all domains are described through a map like:

#+BEGIN_EXAMPLE
domain_voltage_map = {(1,21):-200*V, (21,41):0*V, (41,61):200*V, 61:-500*2*V, 62:500*2*V}
#+END_EXAMPLE

The output =.npz= file contains the solved integral function evaluated
at the boundary.  It can be used for input to the rastering step.

** Raster

This step evaluates the solution from the prior step at points throughout the volume.



** Plot

The =.npz= file produced above can be used as desired.  The =larf= command line tool can use this file to produce some plots.  Like the solution, a plot section of the configuration file is specified and it should associate a raster which is compatible with the solution.  This compatibility is required to get the axis scale correct.

#+BEGIN_SRC sh
  $ larf plot -o parallel-near.pdf -p near parallel-near-d10.npz
#+END_SRC

The extension of the output file determines its format.

[[./parallel-near.png]]

* Configuration

The =larf= tool relies on a configuration file to specify parameters that are expected to be reused between calls to the =larf= command.  The format of this file follows the "INI" schema which consists of named sections of key/value pairs.  Some simple interpretation semantics are then overlayed.  The default configuration file is in the current working directory and named [[./larf.cfg][=larf.cfg=]].  A different file can be specified with the =-c= option

#+BEGIN_SRC sh
  $ larf -c myconfig.cfg ...
#+END_SRC

** Section categories and names

Each section name is two words giving the section type or category and an instance name.
For example this section is in the =mesh= category and named =parallel=:

#+BEGIN_EXAMPLE
  [mesh parallel]
  # ... key/value pairs
#+END_EXAMPLE

** Configuration items

There are two types of key/value configuration items.  

- directives :: reserved keys used to direct the configuration
- parameters :: key/value pairs taken at face-value

The directives depend on the section category as described:

*** Functional categories

The following categories are "functional":

- mesh :: describe how to construct a surface mesh
- boundary :: describe a boundary potential
- raster :: describe how to raster the solution over some space
- plot :: make a plot

These categories are called "functional" as they are meant to describe a function to call and its parameters.  The "function" is described as a Python "dotted" path consisting of one or more modules and an object.  The parameter set is built from two sources of key/values pairs.  First, a =param= key can be specified and all key/value pairs in the associated =params= section will be used.  This set will be updated with any other key/value pairs given in the original configuration section.  An example makes this clear:

#+BEGIN_EXAMPLE
  [mesh parallel]
  methods = larf.wires.parallel
  params = small dune
  lcar = 2.5*mm                   

  [params small]
  nwires = 20

  [params dune]
  pitch = 5*mm
  gap = 5*mm
  radius = 150*um
#+END_EXAMPLE

In the example a mesh named "parallel" is to be build from the =parallel()= method in the =larf.wires= module.  The parameters given to that function consist of the contents of the "=dune=" and "=small=" configuration sections of type =params=.  The parameter set from these to sections is finally updated with the lone =lcar= parameter (characteristic mesh length) which is given directly in the =mesh parallel= section.

Note the use of units for distance quantities.  The =larf= supports a limited set of units including length and time.  

*** The =solve= category

This =solve= category simply aggregates two functional categories by naming a configuration section in each:

- =boundary= :: names a "boundary" category configuration section
- =raster= :: names a "raster" category configuration section

*** Parameter category

As mostly already described, the =params= configuration section category just holds key/value pairs evaluated at face value.  These can be useful if different =larf= command require sharing the same parameters.  For example both the =solve= and =plot= need to share raster parameters.



** Command Line Parameters

You may also specify general parameters to =larf= on the command line which may override those specified in the configuration file.

#+BEGIN_SRC sh
  $ larf -P foo=bar,baz=quax -P domain=11 [...]
#+END_SRC

* Files

Various =larf= commands consume and produce Numpy arrays stored in =.npz= files.  This graph tries to collect some of this.

[[./steps.png]]

(note: may not actually be right)

** Array names

To support arrays from multiple steps and different solutions solutions the arrays encode metadata as:

#+BEGIN_EXAMPLE
<name>_<step>_<type>
#+END_EXAMPLE

Where each label identifies:

- =name= :: an external configuration set by user or =larf= by default,
- =step= :: the step that produced the array,
- =type= :: a category for the array.

The =name= may be free form except it must consist of only alphanumeric characters (and no underscore "=_=").

