#+TITLE Running =larf=

* Overview

LARF calculations are run through the =larf= command line.  
Each possible calculation is in a particular category and has a specific, associated sub-command.
Calculations consume and produce zero or more /results/.  
A result consist of zero or more /arrays/ produced by the calculation and a collection or input /parameters/.
Results are stored in an Sqlite3 database file.  
Each new result is given an unique result ID number.
This number is used to look up a result and provide it as input to a subsequent calculation.
Results can be exported from the database file in various formats including visualization.
Many calculations rely on a configuration file to specify their input parameters.
Be default the configuration file =larf.cfg= is used and the database file =larf.db= is used.
Either file may be explicitly specified to the =larf= command line program.

* Example

As an example, the provided =larf.cfg= is used to calculate a drift velocity field for a geometry of a simple parallel plane capacitor.

#+BEGIN_EXAMPLE
  $ rm -f larf.db
  $ larf mesh capacitor
  $ larf boundary -m 1 capdrift
  $ larf raster -b 2 special
  $ larf velocity -r 3 special
  $ larf list

  result:1 parent:0 2016-07-01 15:30:57.367264 type:mesh       name:capacitor   
    array:1 type:domains      name:domains      dtype:float64  shape:(4240,)
    array:2 type:points       name:points       dtype:float64  shape:(2124, 3)
    array:3 type:triangles    name:triangles    dtype:int64    shape:(4240, 3)

  result:2 parent:1 2016-07-01 15:31:24.955436 type:boundary   name:capdrift    
    array:4 type:coeff        name:dirichlet    dtype:float64  shape:(2124,)
    array:5 type:coeff        name:neumann      dtype:float64  shape:(4240,)

  result:3 parent:2 2016-07-01 15:32:34.170297 type:raster     name:special     
    array:6 type:gscalar      name:potential    dtype:float64  shape:(40, 3, 40)
    array:7 type:mgrid        name:domain       dtype:float64  shape:(3, 40, 3, 40)

  result:4 parent:3 2016-07-01 15:34:08.496289 type:velocity   name:special     
    array:8 type:mgrid        name:domain       dtype:float64  shape:(3, 40, 3, 40)
    array:9 type:gvector      name:velocity     dtype:float64  shape:(3, 40, 3, 40)
#+END_EXAMPLE


** Mesh

The "mesh" (or "grid" in BEM++ language) describes the boundary surface in terms of facets (triangles in this case).  The mesh is defined in terms of three quantities:

- =vertices= :: a 2D array of 3D Cartesian coordinates of points from which the facets are made.
- =elements= :: a 2D array of ordered triplets of indices into the vertices array.  The ordering is such that the normal direction produced by the right-hand-rule points into the region of zero field (ie, into the material or away from the volume where the field is to be calculated).
- =domains= :: a 1D array with each entry providing a domain index for each entry in the /elements/ array.  Domain indices are simply numbers used to associate a set of mesh elements (this is used to assign a boundary potential).

Meshes can be provided in a number of ways:

- [[http://gmsh.info/doc/texinfo/gmsh.html#MSH-ASCII-file-format][MSH ASCII format]] files with care taken to encode the domain indices.
- Numpy =.npz= format with keys named as in the above list.
- Generated internally by =larf mesh=

To generate a mesh with =larf mesh= one names a =[mesh]= section in the =larf.cfg= file.  More info on configuration is below.  Generated meshes can be saved to one of the supported file formats:

#+BEGIN_SRC sh
  $ larf mesh -o one.msh one
  $ larf mesh -o parallel.npz parallel
  $ larf mesh -o uboone.npz -o uboone.msh uboone
#+END_SRC

Meshes in MSH format can be easily viewed with =gmsh=:

#+BEGIN_SRC sh
  $ gmsh uboone.msh
#+END_SRC


** Solve

This step integrates the Laplace equation and evaluates that solution
at the boundary using potentials defined on the mesh.  Ultimately,
boundary potentials are defined in terms of the domain indices
(described above).  There are two classes of potentials to solve:
/drift/ and /weighting/.  Solving for the /drift/ potential requires
some detailed boundary potential specification and is accomplished by
mapping individual or ranges of domain indices to voltage values.
The /weighting/ potential requires only specifying which domain to
focus on, setting it to unit voltage and setting all other domains to
0V.  To simplify the specification each case has its own rule to apply
parameters to define the potential.  This is all specified through the
command line and configuration file.

#+BEGIN_SRC sh
  $ larf solve -p weghting -d 11 -o parallel-near-d10.npz parallel.msh
  $ larf solve -p drift          -o parallel-drift.npz parallel.msh
#+END_SRC

The first example uses the /weighting/ potential defined in =larf.cfg= with the domain index 11 called out as special (ie, that wire will be set to 1V).  The second example uses the /drift/ potential defined in =larf.cfg=.  In that definition the potential of all domains are described through a map like:

#+BEGIN_EXAMPLE
domain_voltage_map = {(1,21):-200*V, (21,41):0*V, (41,61):200*V, 61:-500*2*V, 62:500*2*V}
#+END_EXAMPLE

The output =.npz= file contains the solved integral function evaluated
at the boundary.  It can be used for input to the rastering step.

** Raster

This step evaluates the solution from the prior step at points throughout the volume.



** Plot

The =.npz= file produced above can be used as desired.  The =larf= command line tool can use this file to produce some plots.  Like the solution, a plot section of the configuration file is specified and it should associate a raster which is compatible with the solution.  This compatibility is required to get the axis scale correct.

#+BEGIN_SRC sh
  $ larf plot -o parallel-near.pdf -p near parallel-near-d10.npz
#+END_SRC

The extension of the output file determines its format.

[[./parallel-near.png]]

